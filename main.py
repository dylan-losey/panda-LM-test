import pybullet as p
import pybullet_data
import numpy as np
import os
import time
import config
from robot import Panda


## internal function
# move to position and orientation
def move_to_pose(ee_position, ee_euler):
    for i in range (1000):
        panda.move_to_pose(ee_position=ee_position, ee_quaternion=p.getQuaternionFromEuler(ee_euler), positionGain=0.01)
        p.stepSimulation()
        time.sleep(config.control_dt)

## functions that the LM can use
# side grasp with the fingers along the +-z axis
# at angle = 0 the gripper in pointing along the positive x axis
def side_grasp_vertical(angle):
    ee_euler = [np.pi/2, 0, np.pi/2 + angle]
    state = panda.get_state()
    move_to_pose(state["ee-position"], ee_euler)
# side grasp with the fingers perpendicular to the z axis
# at angle = 0 the gripper in pointing along the positive x axis
def side_grasp_horizontal(angle):
    ee_euler = [np.pi, -np.pi/2, angle]
    state = panda.get_state()
    move_to_pose(state["ee-position"], ee_euler)
# top grasp
# at angle = 0 the fingers are along the +-y axis
def top_grasp(angle):
    ee_euler = [np.pi, 0, angle]
    state = panda.get_state()
    move_to_pose(state["ee-position"], ee_euler)
# spin gripper
# spins the gripper fingers in a circle by theta radians
def spin_gripper(theta):
    state = panda.get_state()
    new_theta = theta + state["joint-position"][6]
    for i in range(500):
        p.setJointMotorControl2(panda.panda, 6, p.POSITION_CONTROL, targetPosition=new_theta, positionGain=0.01)
        p.stepSimulation()
        time.sleep(config.control_dt)
# move to a given position
def move_to_position(position):
    state = panda.get_state()
    move_to_pose(position, state["ee-euler"])
# open gripper
def open_gripper():
    for i in range(300):
        panda.open_gripper()
        p.stepSimulation()
        time.sleep(config.control_dt)
# close gripper
def close_gripper():
    for i in range(300):
        panda.close_gripper()
        p.stepSimulation()
        time.sleep(config.control_dt)
# terminate
def task_completed():
    p.disconnect()


# create simulation and place camera
physicsClient = p.connect(p.GUI)
p.setGravity(0, 0, -9.81)
p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0)
p.resetDebugVisualizerCamera(cameraDistance=config.cameraDistance, 
                                cameraYaw=config.cameraYaw,
                                cameraPitch=config.cameraPitch, 
                                cameraTargetPosition=config.cameraTargetPosition)

# load the objects
urdfRootPath = pybullet_data.getDataPath()
plane = p.loadURDF(os.path.join(urdfRootPath, "plane.urdf"), basePosition=[0, 0, -0.625])
table = p.loadURDF(os.path.join(urdfRootPath, "table/table.urdf"), basePosition=[0.5, 0, -0.625])
cube = p.loadURDF("objects/simple_objects/cube.urdf", basePosition=[0.6, 0, 0.2], baseOrientation=p.getQuaternionFromEuler([0, 0, 0.7]))

# load the robot
panda = Panda(basePosition=config.baseStartPosition,
                baseOrientation=p.getQuaternionFromEuler(config.baseStartOrientationE),
                jointStartPositions=config.jointStartPositions)

# let the scene initialize
for i in range(100):
    p.stepSimulation()
    time.sleep(config.control_dt)

# response
'''
The center of the beam is in position [0.6, 0, 0.2], rotated by 0.7 around z-axis
The beam is 0.05 wide, 0.05 depth, and 0.4 height
'''

# enter the code generated by the LM below:


import math

# Calculate approach position (0.1 m behind beam in gripper direction)
angle = 0.7
offset = 0.1
x_approach = 0.6 - offset * math.cos(angle)
y_approach = 0.0 - offset * math.sin(angle)
z_approach = 0.3


# Orient gripper for side grasp [horizontal] aligned with beam
side_grasp_horizontal(angle)

# Move to approach position
move_to_position([x_approach, y_approach, z_approach])



# Move to beam grasp position (center at z=0.3 m)
move_to_position([0.6, 0.0, 0.3])

# Close gripper to secure beam
close_gripper()

# Lift beam to safe height (clear table and obstacles)
move_to_position([0.6, 0.0, 0.4])

# Move beam closer to robot (x=0.4 m)
move_to_position([0.4, 0.0, 0.4])

# Lower beam to placement height
move_to_position([0.4, 0.0, 0.3])

# Release beam
open_gripper()

# Retract gripper to safe position
move_to_position([0.4, 0.0, 0.5])

# Task completed
task_completed()