import pybullet as p
import pybullet_data
import numpy as np
import os
import time
import config
from cameras import ExternalCamera
from robot import Panda
import matplotlib.pyplot as plt
from objects import objects


## internal functions

# move to position and orientation
def move_to_pose(ee_position, ee_euler):
    for i in range (1000):
        panda.move_to_pose(ee_position=ee_position, ee_quaternion=p.getQuaternionFromEuler(ee_euler), positionGain=0.01)
        p.stepSimulation()
        time.sleep(config.control_dt)


## functions that the LM can use

# side grasp with the fingers along the +-z axis
# at angle = 0 the gripper in pointing along the positive x axis
def side_grasp_vertical(angle):
    ee_euler = [np.pi/2, 0, np.pi/2 + angle]
    state = panda.get_state()
    move_to_pose(state["ee-position"], ee_euler)

# side grasp with the fingers perpendicular to the z axis
# at angle = 0 the gripper in pointing along the positive x axis
def side_grasp_horizontal(angle):
    ee_euler = [np.pi, -np.pi/2, angle]
    state = panda.get_state()
    move_to_pose(state["ee-position"], ee_euler)

# top grasp
# at angle = 0 the fingers are along the +-y axis
def top_grasp(angle):
    ee_euler = [np.pi, 0, angle]
    state = panda.get_state()
    move_to_pose(state["ee-position"], ee_euler)

# spin gripper
# spins the gripper fingers in a circle by theta radians
def spin_gripper(theta):
    state = panda.get_state()
    new_theta = theta + state["joint-position"][6]
    for i in range(500):
        p.setJointMotorControl2(panda.panda, 6, p.POSITION_CONTROL, targetPosition=new_theta, positionGain=0.01)
        p.stepSimulation()
        time.sleep(config.control_dt)

# move to a given position
def move_to_position(position):
    state = panda.get_state()
    move_to_pose(position, state["ee-euler"])

# open gripper
def open_gripper():
    for i in range(300):
        panda.open_gripper()
        p.stepSimulation()
        time.sleep(config.control_dt)

# close gripper
def close_gripper():
    for i in range(300):
        panda.close_gripper()
        p.stepSimulation()
        time.sleep(config.control_dt)

# terminate
def task_completed():
    p.disconnect()


# create simulation and place the GUI camera
physicsClient = p.connect(p.GUI)
p.setGravity(0, 0, -9.81)
p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0)
p.resetDebugVisualizerCamera(cameraDistance=config.cameraDistance, 
                                cameraYaw=config.cameraYaw,
                                cameraPitch=config.cameraPitch, 
                                cameraTargetPosition=config.cameraTargetPosition)

# load the objects
urdfRootPath = pybullet_data.getDataPath()
plane = p.loadURDF(os.path.join(urdfRootPath, "plane.urdf"), basePosition=[0, 0, -0.625])
table = p.loadURDF(os.path.join(urdfRootPath, "table/table.urdf"), basePosition=[0.5, 0, -0.625])
cube = objects.SimpleObject("cube.urdf", basePosition=[0.5, -0.3, 0.025], baseOrientation=p.getQuaternionFromEuler([0, 0, 0.7]))
cabinet = objects.CollabObject("cabinet.urdf", basePosition=[0.9, 0.0, 0.2], baseOrientation=p.getQuaternionFromEuler([0, 0, np.pi]))

# load the robot
# files modified so that robot loads from `franka_panda` folder, which has altered URDF for greater workspace
panda = Panda(basePosition=config.baseStartPosition,
                baseOrientation=p.getQuaternionFromEuler(config.baseStartOrientationE),
                jointStartPositions=config.jointStartPositions)

# add an external camera
# this camera takes observations of the environment that can be leveraged by the VLM
onboard_camera = ExternalCamera(cameraDistance=config.ext_cameraDistance, 
                                    cameraYaw=config.ext_cameraYaw, 
                                    cameraPitch=config.ext_cameraPitch,
                                    cameraTargetPosition=config.ext_cameraTargetPosition)

# let the scene initialize
for i in range(100):
    p.stepSimulation()
    time.sleep(config.control_dt)

# get an image of the initial scene
image = onboard_camera.get_image()
plt.imsave('images/init_state.png', image)

## Add code as needed to detect the centers of objects, rotations, etc.
# your code for detect_object here

## enter the code generated by the LM below:
# your results from the LM here
